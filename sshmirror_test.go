package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/0leksandr/my.go"
	"io/ioutil"
	"os"
	"os/exec"
	"reflect"
	"regexp"
	"strings"
	"sync"
	"testing"
	"time"
)

// TODO: test modifying root dir: https://github.com/0leksandr/sshmirror/issues/4
// TODO: test tabs, zero-symbols and others in filenames
// TODO: test files and directories with same name
// MAYBE: reproduce and investigate errors "rsync: link_stat * failed: No such file or directory (2)"
// MAYBE: test tricky filenames: `--`, `.`, `..`, `*`, `:`, `\r`
// MAYBE: test ignored
// MAYBE: duplicate filenames in master chains
// MAYBE: test fallback
// MAYBE: test fsnotify watcher
// MAYBE: emulate slow/bad connection for tricky/complex tests
// MAYBE: random test fails:
//        + initializing master connection count as syncing time, and thus timed out
//        - order of updates changed. WTF?
//        - syncing times out, because (almost) 2 syncing operations were count in
//        - test did not wait for syncing to end. Wait for master was done (much) faster for test, than for client.
//          Also, modification was delayed. As a result, `client.onReady` (for master ready) was triggered between
//          actual modification and received one. Test treated it as ready after modification was processed
//          Chronology:
//          - master ready
//          - test received it, made actual modification
//          - client received it, checking for "zero"-modifications
//          - no modifications found, triggering `onReady` (as of master)
//          - modification received, but too late
//        - `mv a ../b && mv ../c a` is treated as `mv a a` in inotify
//        ¬± nil pointer dereference in `command.ProcessState.Exited()` during cancelling upload
// MAYBE: count every integration test case as a separate test (in IDE's progress bar)
// WONTDO: autogenerated TestModificationsList with combinations of modifications for integration test. Nr combinations
//         (if nr files = 3, nr external files = 2, nr modifications = 4) = (3 + 3 + (5 * 4 - 1)) ^ 4 = 390625

var delaysBasic = [...]float32{ // TODO: non-constant delays (pseudo-random pauses)
	0.,
	0.1,
	0.6,
}
var delaysMaster = [...]float32{
	0.,
	0.1,
	0.4,
	0.6,
	1.,
}

const MovementCleanup = "sleep 0.003" // MAYBE: come up with something better

type TestModificationInterface interface {
	commandVariants() []string
}
type TestSimpleModification struct {
	command string
}
func (modification TestSimpleModification) commandVariants() []string {
	return []string{modification.command}
}
type TestOptionalModification struct {
	command string
}
func (modification TestOptionalModification) commandVariants() []string {
	return []string{
		"",
		modification.command,
	}
}
type TestVariantsModification struct {
	variants []string
}
func (modification TestVariantsModification) commandVariants() []string {
	return modification.variants
}

type TestScenario struct {
	before []Filename
	after  []string // MAYBE: type CommandString
}

type TestModificationsList []TestModificationInterface
func (modifications TestModificationsList) commandsVariants() [][]string {
	//commands := make([][]string, 0, len(modifications))
	//for _, modification := range modifications {
	//	commands = append(commands, modification.commandVariants())
	//}
	////return Twines(commands).([][]string)
	//return CartesianProducts(commands).([][]string)

	if len(modifications) == 0 { return nil }
	nrVariants := 1
	for _, modification := range modifications {
		nrVariants *= len(modification.commandVariants())
	}
	variants0 := modifications[0].commandVariants()
	variants := make([][]string, 0, len(variants0))
	for _, variant := range variants0 { variants = append(variants, []string{variant}) }
	for _, modification := range modifications[1:] {
		modificationVariants := modification.commandVariants()
		newVariants := make([][]string, 0, len(variants) * len(modificationVariants))
		for _, variant := range variants {
			//variantCopy := make([]string, len(variant))
			//copy(variantCopy, variant)

			for _, command := range modificationVariants {
				newVariants = append(newVariants, append(variant, command))
			}
		}
		variants = newVariants
	}
	return variants
}

type TestModificationChain struct { // MAYBE: rename
	before []Filename // MAYBE: split required and optional
	after  TestModificationsList
}
func (chain TestModificationChain) scenarios() []TestScenario {
	variantsAfter := chain.after.commandsVariants()
	scenarios := make([]TestScenario, 0, len(variantsAfter))
	for _, after := range variantsAfter {
		//copyBefore := make([]string, len(before))
		//copy(copyBefore, before)
		//copyAfter := make([]string, len(after))
		//copy(copyAfter, after)

		scenarios = append(scenarios, TestScenario{
			before: chain.before,
			after:  after,
		})
	}
	return scenarios
}

var fileIndex = 0
func generateFilename(inTarget bool) Filename {
	dir := "."
	if inTarget { dir += "/target" }
	fileIndex++
	return Filename(fmt.Sprintf("%s/file-%d", dir, fileIndex))

	//var symbols []string
	//for _, symbol := range []rune("abc,.;'[]\\<>?\"{}|123`~!@#$%^&*()-=_+ –∞–±–≤üôÇüëç‚ùó") {
	//	symbols = append(symbols, string(symbol))
	//}
	//symbols = append(
	//	symbols,
	//	"\\'",
	//	"\\\\'",
	//	"\\\\\\'",
	//	"\\\\\\\\'",
	//	"\\\\\\\\\\'",
	//)
	//nrSymbols := rand.Intn(150) + 1
	//dir := "./"
	//if inTarget { dir += "target/" }
	//var filename string
	//for i := 0; i < nrSymbols; i++ {
	//	filename += symbols[rand.Intn(len(symbols))]
	//}
	//if my.InArray(
	//	filename,
	//	[]string{
	//		".",
	//		"..",
	//		"*",
	//		".gitignore",
	//		"target",
	//	},
	//) {
	//	return generateFilename(inTarget)
	//}
	//return Filename(dir + filename)
}
func create(filename Filename) string { // MAYBE: touch
	return fmt.Sprintf("touch %s", filename.Escaped())
}
var contentIndex = 0
func write(filename Filename) string {
	contentIndex++
	return fmt.Sprintf("echo %d > %s", contentIndex, filename.Escaped())
}
func move(from, to Filename) string {
	return fmt.Sprintf("mv %s %s", from.Escaped(), to.Escaped())
}
func remove(filename Filename) string {
	return fmt.Sprintf("/bin/rm %s", filename.Escaped())
}

func basicModificationChains() []TestModificationChain {
	return []TestModificationChain{
		(func(a Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{},
				after: TestModificationsList{
					TestSimpleModification{create(a)},
				},
			}
		})(generateFilename(true)),
		(func(a, b Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{a, b},
				after: TestModificationsList{
					TestSimpleModification{remove(a)},
					TestSimpleModification{move(b, a)},
				},
				//Moved{b, a},
			}
		})(generateFilename(true), generateFilename(true)),
		(func(a, b, cExt Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{b},
				after: TestModificationsList{
					TestSimpleModification{write(a)},
					TestSimpleModification{move(a, b)},
					TestVariantsModification{[]string{
						remove(b),
						move(b, cExt),
					}},
					TestSimpleModification{MovementCleanup},
				},
				// Deleted{a},
				// Deleted{b},
			}
		})(generateFilename(true), generateFilename(true), generateFilename(false)),
		(func(a, b, c Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{a},
				after: TestModificationsList{
					TestSimpleModification{move(a, b)},
					TestSimpleModification{move(b, c)},
				},
				//Moved{a, c},
				//Deleted{b},
			}
		})(generateFilename(true), generateFilename(true), generateFilename(true)),
		(func(a, b Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{a, b},
				after: TestModificationsList{
					TestSimpleModification{move(a, b)},
					TestSimpleModification{write(a)},
				},
			}
		})(generateFilename(true), generateFilename(true)),
		(func(a, b, c Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{a, b, c},
				after: TestModificationsList{
					TestSimpleModification{move(a, b)},
					TestSimpleModification{write(b)},
					TestVariantsModification{[]string{
						"",
						create(a),
						write(a),
						move(c, a),
					}},
					TestSimpleModification{write(a)},
				},
			}
		})(generateFilename(true), generateFilename(true), generateFilename(true)),
		(func(a, b, c Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{a, b, c},
				after: TestModificationsList{
					TestSimpleModification{move(a, c)},
					TestSimpleModification{move(b, a)},
					TestSimpleModification{move(c, b)},
				},
			}
		})(generateFilename(true), generateFilename(true), generateFilename(true)),
		(func(a, b, cExt Filename) TestModificationChain { // group begin: tricky Watcher cases
			return TestModificationChain{
				before: []Filename{a},
				after: TestModificationsList{
					TestSimpleModification{move(a, cExt)},
					TestVariantsModification{[]string{
						create(b),
						write(b),
					}},
				},
			}
		})(generateFilename(true), generateFilename(true), generateFilename(false)),
		(func(a, bExt, cExt Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{a, cExt},
				after: TestModificationsList{
					TestSimpleModification{move(a, bExt)},
					TestSimpleModification{move(cExt, a)},
				},
			}
		})(generateFilename(true), generateFilename(false), generateFilename(false)),
		(func(a, bExt, c Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{a},
				after: TestModificationsList{
					TestSimpleModification{move(a, bExt)},
					TestSimpleModification{move(bExt, c)},
				},
			}
		})(generateFilename(true), generateFilename(false), generateFilename(true)), // group end
		(func(a, bExt, cExt Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{a, bExt, cExt}, // MAYBE: find a normal way to test, and remove `a` (or make it optional)
				after: TestModificationsList{
					TestSimpleModification{move(bExt, a)},
					TestOptionalModification{write(a)},
					TestSimpleModification{move(a, cExt)},
					TestSimpleModification{MovementCleanup},
				},
			}
		})(generateFilename(true), generateFilename(false), generateFilename(false)),
		(func(a, b, c Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{a, b},
				after: TestModificationsList{
					TestSimpleModification{move(b, c)},
					TestSimpleModification{move(a, b)},
					TestVariantsModification{[]string{
						"",
						write(c),
						write(b),
					}},
				},
			}
		})(generateFilename(true), generateFilename(true), generateFilename(true)),
		(func(a, b, c Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{a, b, c},
				after: TestModificationsList{
					TestSimpleModification{move(a, b)},
					TestSimpleModification{move(b, c)},
					TestSimpleModification{remove(c)},
				},
				//Deleted{b},
				//Deleted{a},
				//Deleted{c},
			}
		})(generateFilename(true), generateFilename(true), generateFilename(true)),
		(func(a, b Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{a},
				after: TestModificationsList{
					TestSimpleModification{move(a, b)},
					TestSimpleModification{move(b, a)},
				},
				//Deleted{b},
			}
		})(generateFilename(true), generateFilename(true)),
		(func(a, bExt, c Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{a, c},
				after: TestModificationsList{
					TestSimpleModification{move(a, bExt)},
					TestVariantsModification{[]string{
						move(bExt, a),
						move(bExt, c),
					}},
				},
			}
		})(generateFilename(true), generateFilename(false), generateFilename(true)),
		(func(a, b Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{a},
				after: TestModificationsList{
					TestSimpleModification{move(a, b)},
					TestOptionalModification{write(a)},
					TestOptionalModification{write(b)},
					TestOptionalModification{remove(b)},
				},
			}
		})(generateFilename(true), generateFilename(true)),
		(func(a, b, c Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{a, c},
				after: TestModificationsList{
					TestSimpleModification{move(a, b)},
					TestOptionalModification{write(a)},
					TestSimpleModification{move(c, b)},
				},
			}
		})(generateFilename(true), generateFilename(true), generateFilename(true)),
		(func(a, b Filename) TestModificationChain { // group begin
			return TestModificationChain{
				before: []Filename{a},
				after: TestModificationsList{
					TestOptionalModification{remove(a)},
					TestSimpleModification{write(a)},
					TestSimpleModification{move(a, b)},
					TestOptionalModification{write(a)},
					TestOptionalModification{remove(a)},
				},
			}
		})(generateFilename(true), generateFilename(true)),
	}
}
func filenameModificationChains() []TestModificationChain {
	apostrophes := []string{
		"\\'",
		"\\\\'",
		"\\\\\\'",
		"\\\\\\\\'",
		"\\\\\\\\\\'",
	}
	filenames := make([]Filename, 0, len(apostrophes))
	for i := 0; i <= len(apostrophes); i++ {
		filenames = append(
			filenames,
			Filename("abc,.;'[]\\<>?\"{}|123`~!@#$%^&*()-=_+ \t\n–∞–±–≤üôÇüëç‚ùó" + strings.Join(apostrophes[:i], "")),
		)
	}
	for i, filename := range filenames { filenames[i] = "./target/" + filename }
	chains := []func(filename Filename) TestModificationChain{
		func(filename Filename) TestModificationChain {
			return TestModificationChain{after: TestModificationsList{TestSimpleModification{create(filename)}}}
		},
		func(filename Filename) TestModificationChain {
			return TestModificationChain{after: TestModificationsList{TestSimpleModification{write(filename)}}}
		},
		func(filename Filename) TestModificationChain {
			filename2 := filename + "$"
			return TestModificationChain{
				before: []Filename{filename2},
				after: TestModificationsList{TestSimpleModification{move(filename2, filename)}},
			}
		},
		func(filename Filename) TestModificationChain {
			return TestModificationChain{
				before: []Filename{filename},
				after: TestModificationsList{TestSimpleModification{remove(filename)}},
			}
		},
	}
	chains2 := make([]TestModificationChain, 0, len(filenames) * len(chains))
	for _, filename := range filenames {
		for _, chain := range chains {
			chains2 = append(chains2, chain(filename))
		}
	}
	return chains2
}
func modificationChains() []TestModificationChain {
	basicChains := basicModificationChains()
	chains := make([]TestModificationChain, 0, (len(basicChains) * len(delaysBasic)) + len(delaysMaster))
	simplify := func(modifications []TestModificationInterface) []TestModificationInterface {
		simplified := make([]TestModificationInterface, 0, len(modifications))
		for _, modification := range modifications {
			variants := modification.commandVariants()
			simplified = append(simplified, TestSimpleModification{variants[len(variants) - 1]})
		}
		return simplified
	}
	mergeDelays := func(modifications []TestModificationInterface, delaySeconds float32) []TestModificationInterface {
		if len(modifications) == 0 { return nil }
		merged := make([]TestModificationInterface, 0, len(modifications) * 2 + 1)
		merged = append(merged, modifications[0])
		for i := 1; i < len(modifications); i++ {
			merged = append(merged, TestSimpleModification{fmt.Sprintf("sleep %f", delaySeconds)})
			merged = append(merged, modifications[i])
		}
		return merged
	}
	var masterChain TestModificationChain
	for _, chain := range basicChains {
		masterChain.before = append(masterChain.before, chain.before...)
		masterChain.after = append(masterChain.after, simplify(chain.after)...)
	}
	for _, delaySeconds := range delaysMaster {
		chains = append(chains, TestModificationChain{
			before: masterChain.before,
			after:  mergeDelays(masterChain.after, delaySeconds),
		})
	}
	for _, delaySeconds := range delaysBasic {
		for _, chain := range basicChains {
			chains = append(chains, TestModificationChain{
				before: chain.before,
				after:  mergeDelays(chain.after, delaySeconds),
			})
		}
	}
	chains = append(chains, filenameModificationChains()...)
	return chains
}

type TestConfig struct {
	IdentityFile    string
	RemoteAddress   string
	RemotePath      string
	TimeoutSeconds  int
	NrThreads       int
	ErrorCmd        string
	StopOnFail      bool
	IntegrationTest bool
}
func (TestConfig) New(filename string) TestConfig {
	configFile, err := os.Open(filename)
	PanicIf(err)
	defer func() { Must(configFile.Close()) }()
	testConfig := TestConfig{}
	Must(json.NewDecoder(configFile).Decode(&testConfig))

	fileContent, err := ioutil.ReadFile(filename)
	PanicIf(err)
	Must(testConfig.check(fileContent))

	return testConfig
}
func (config TestConfig) check(originalContent []byte) error {
	value := reflect.ValueOf(config)
	for i := 0; i < value.NumField(); i++ {
		field := value.Field(i)
		fieldName := value.Type().Field(i).Name
		allowEmpty := field.Kind() == reflect.Bool || fieldName == "ErrorCmd"
		if !allowEmpty && reflect.New(field.Type()).Elem().Interface() == field.Interface() {
			return errors.New(fmt.Sprintf("field %s is empty", fieldName))
		}
	}

	buffer := &bytes.Buffer{}
	if err := json.NewEncoder(buffer).Encode(config); err != nil { return err }
	replaceBlanks := func(text []byte) []byte { // MAYBE: something smarter
		for from, to := range map[string][]byte{
			"\\n *": {},
			"\": +": []byte("\":"),
		} {
			text = regexp.MustCompile(from).ReplaceAll(text, to)
		}
		return text
	}
	if !bytes.Equal(replaceBlanks(originalContent), replaceBlanks(buffer.Bytes())) {
		return errors.New("some fields are missing")
	}

	return nil
}

func TestIntegration(t *testing.T) {
	currentDir, err := os.Getwd()
	PanicIf(err)
	sandbox := fmt.Sprintf("%s/sandbox", currentDir)
	testConfig := TestConfig{}.New(fmt.Sprintf("%s/test-config.json", currentDir))

	controlPathFile, err := ioutil.TempFile("", "sshmirror-test-")
	PanicIf(err)
	controlPath := controlPathFile.Name()
	Must(os.Remove(controlPath))
	defer func() { Must(os.Remove(controlPath)) }()
	sshCmd := fmt.Sprintf("ssh -t -o ControlPath=%s -i %s", controlPath, testConfig.IdentityFile)
	var masterConnectionReady sync.WaitGroup
	masterConnectionReady.Add(1)
	go func() {
		my.RunCommand(
			currentDir,
			fmt.Sprintf("%s -M %s -t 'echo done && sleep 300'", sshCmd, testConfig.RemoteAddress),
			func(string) { masterConnectionReady.Done() },
			nil,
		)
		panic("master connection dead")
	}()
	masterConnectionReady.Wait()

	executeRemote := func(remotePath string, cmd string) []string {
		result := make([]string, 0)
		my.RunCommand(
			"",
			fmt.Sprintf(
				"%s %s -t \"cd %s && (%s)\"",
				sshCmd,
				testConfig.RemoteAddress,
				remotePath,
				cmd,
			),
			func(out string) {
				result = append(result, out)
			},
			nil,
		)
		return result
	}

	var SUTsDone sync.WaitGroup

	reset := func(remotePath string, localPath string, full bool) {
		var resetCmd string
		if full {
			//resetCmd = "find . -not -path . -not -name '.gitignore' -exec rm -r {} +"
			resetCmd = "find . -type f -not -name '.gitignore' -delete && find . -type d -delete"
		} else {
			//resetCmd = "find . -not -name '.gitignore' -not -name 'target' -delete"
			resetCmd = "find . -type f -not -name '.gitignore' -delete"
		}
		my.RunCommand(
			localPath,
			resetCmd,
			nil,
			func(err string) { panic(err) },
		)
		executeRemote(remotePath, resetCmd)
	}
	reset(testConfig.RemotePath, sandbox, true)
	var cleanUp sync.WaitGroup
	cleanUp.Add(1)
	defer func() {
		SUTsDone.Wait()
		reset(testConfig.RemotePath, sandbox, true)
		cleanUp.Done()
	}()

	chains := modificationChains()

	my.Dump2(time.Now())
	var nrScenarios int
	for _, chain := range chains { nrScenarios += len(chain.scenarios()) }
	my.Dump(nrScenarios)

	scenarios := make(chan TestScenario, nrScenarios)
	for _, chain := range chains {
		for _, scenario := range chain.scenarios() {
			scenarios <- scenario
		}
	}
	close(scenarios)

	loggers := make([]*Logger, 0, testConfig.NrThreads)
	for i := 0; i < testConfig.NrThreads; i++ {
		loggers = append(loggers, &Logger{
			debug: &InMemoryDebugLogger{formatter: LogFormatter{timestamps: true}},
			error: (func() ErrorLogger {
				if testConfig.ErrorCmd != "" {
					return ComboErrorLogger{[]ErrorLogger{
						ErrorCmdLogger{testConfig.ErrorCmd},
						StdErrLogger{},
					}}
				} else {
					return StdErrLogger{}
				}
			})(),
		})
	}

	var wg sync.WaitGroup
	wg.Add(testConfig.NrThreads)
	scenarioIdx := 0
	for i := 0; i < testConfig.NrThreads; i++ {
		go func(processId int) {
			processDir := fmt.Sprintf("process%d", processId)
			targetDir := fmt.Sprintf("%s/target", processDir)
			localSandbox := fmt.Sprintf("%s/%s", sandbox, processDir)
			remoteSandbox := fmt.Sprintf("%s/%s", testConfig.RemotePath, processDir)
			localTarget := fmt.Sprintf("%s/%s", sandbox, targetDir)
			remoteTarget := fmt.Sprintf("%s/%s", testConfig.RemotePath, targetDir)
			mkdir := fmt.Sprintf("mkdir -p %s", targetDir)
			my.RunCommand(sandbox, mkdir, nil, func(err string) { panic(err) })
			executeRemote(testConfig.RemotePath, mkdir)

			logger := loggers[processId - 1]

			var syncing Locker
			SUTsDone.Add(1)
			if testConfig.IntegrationTest {
				command := exec.Command(
					"./sshmirror",
					"-i="+testConfig.IdentityFile,
					"-v=0",
					localTarget,
					testConfig.RemoteAddress,
					remoteTarget,
				)
				command.Dir = currentDir
				defer func() {
					Must(command.Process.Kill())
					SUTsDone.Done()
				}()
				Must(command.Start())
			} else {
				client := SSHMirror{}.New(Config{
					localDir:     localTarget,
					remoteHost:   testConfig.RemoteAddress,
					remoteDir:    remoteTarget,
					identityFile: testConfig.IdentityFile,
					connTimeout:  testConfig.TimeoutSeconds,
					errorCmd:     testConfig.ErrorCmd,
				})
				client.SetLogger(*logger)
				client.onReady = func() {
					logger.Debug("client.onReady")
					syncing.Unlock()
				}
				go client.Run()
				defer func() {
					Must(client.Close())
					SUTsDone.Done()
				}()
				client.remote.Ready().Wait()
			}

			awaitSync := func() {
				if testConfig.IntegrationTest {
					time.Sleep(time.Duration(testConfig.TimeoutSeconds) * time.Second)
				} else {
					synced := *cancellableTimer(
						time.Duration(testConfig.TimeoutSeconds) * time.Second,
						func() {
							my.Dump("stuck logs:")
							logger.Debug("")
							logger.debug.(*InMemoryDebugLogger).collector.Print()
							panic("test failed")
						},
					)
					syncing.Wait()
					synced()
				}
			}

			for scenario := range scenarios {
				(func() {
					my.Dump(scenarioIdx)
					scenarioIdx++ // MAYBE: atomic
				})()
				logger.Debug("scenario", scenario)

				check := func() {
					localPath := localTarget
					remotePath := remoteTarget
					hashCmd := `
(
  find . -type f -print0  | LC_ALL=C sort -z | xargs -0 sha1sum;
  find . \( -type f -o -type d \) -print0 | LC_ALL=C sort -z | xargs -0 stat -c '%n %a'
) | sha1sum
`
					var localHash string
					for localHash == "" {
						my.RunCommand(
							localPath,
							hashCmd,
							func(out string) {
								localHash = out
							},
							func(err string) { panic(err) },
						)
					}

					var remoteHash []string
					for len(remoteHash) == 0 {
						remoteHash = executeRemote(remotePath, hashCmd)
					}

					if !reflect.DeepEqual([]string{localHash}, remoteHash) {
						t.Error("hashes mismatch", localHash, remoteHash)

						logger.Debug("check failed")
						logger.Debug("processId", processId)
						for _, cmd := range []string{
							"find . -type f -print0 | LC_ALL=C sort -z | xargs -0 -r sha1sum",
							//"find . \\( -type f -o -type d \\) -print0 | LC_ALL=C sort -z | xargs -0 stat -c '%n %a'",
							//hashCmd,
							//"tree ../..",
							"find . -type f -printf \"%p:\" -exec cat {} \\; | LC_ALL=C sort", // MAYBE: fix `cat`'ing empty files
						} {
							local := make([]string, 0)
							my.RunCommand(
								localPath,
								cmd,
								func(out string) { local = append(local, out) },
								func(err string) { panic(err) },
							)
							remote := executeRemote(remotePath, cmd)
							logger.Debug("cmd", cmd)
							logger.Debug("local", local)
							logger.Debug("remote", remote)
							equal := reflect.DeepEqual(local, remote)
							logger.Debug("equal", equal)
							if !equal {
								var diff []string
								my.RunCommand(
									"",
									fmt.Sprintf(
										"bash -c 'diff <(echo \"%s\") <(echo \"%s\")'",
										strings.Join(local, "\n"),
										strings.Join(remote, "\n"),
									),
									func(out string) { diff = append(diff, out) },
									func(err string) { logger.Error(err) },
								)
								logger.Debug("diff", diff)
							}
						}
						if testConfig.StopOnFail {
							my.Dump("logs:")
							logger.debug.(*InMemoryDebugLogger).collector.Print()
							panic("test failed")
						}
					}
				}

				//scenario.applyTarget(processId)

				for _, filename := range scenario.before {
					logger.Debug("file.before", filename)

					if !testConfig.IntegrationTest { syncing.Lock() }

					my.RunCommand(
						localSandbox,
						write(filename),
						nil,
						func(err string) { panic(err) },
					)
				}
				awaitSync()

				for _, command := range scenario.after {
					logger.Debug("command.after", command)

					if command != "" && command != MovementCleanup {
						if !testConfig.IntegrationTest { syncing.Lock() }

						my.RunCommand(
							localSandbox,
							command,
							nil,
							func(err string) { panic(err) },
						)
					}
				}
				awaitSync()
				check()
				reset(remoteSandbox, localSandbox, false)
				logger.debug.(*InMemoryDebugLogger).collector.Clear()
			}

			wg.Done()
		}(i + 1)
	}
	wg.Wait()
}
